#!/usr/bin/env python3
import os
import hashlib
import tempfile
import subprocess
from datetime import datetime
import pymysql.cursors

# ----------------------------------------------------
# DATABASE CONFIGURATION
# ----------------------------------------------------
DB_CONFIG = {
    "host": "localhost",
    "user": "radius",
    "password": "modi@2000",
    "database": "radius",
    "cursorclass": pymysql.cursors.DictCursor,
}

# ----------------------------------------------------
# FILE PATHS
# ----------------------------------------------------
CHAP_SECRETS_PATH = "/etc/accel-ppp/chap-secrets"
HASH_STATE_PATH = "/var/lib/accel-ppp/chap-secrets.sha256"

# ----------------------------------------------------
# BEHAVIOR FLAGS
# ----------------------------------------------------
# Leave False to avoid any chance of tunnel flap.
# Usually NOT needed: accel reads chap-secrets on auth for new sessions.
TRY_RELOAD_IF_AVAILABLE = False

# ----------------------------------------------------
# HELPERS
# ----------------------------------------------------
def sha256_bytes(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()

def atomic_write(path: str, content: bytes, mode: int = 0o600) -> None:
    """
    Atomic replace:
      - write temp file in same directory
      - fsync
      - rename over target
    """
    directory = os.path.dirname(path) or "."
    os.makedirs(directory, exist_ok=True)

    fd, tmp_path = tempfile.mkstemp(prefix=".chap.", dir=directory)
    try:
        with os.fdopen(fd, "wb") as f:
            f.write(content)
            f.flush()
            os.fsync(f.fileno())
        os.chmod(tmp_path, mode)
        os.replace(tmp_path, path)
    finally:
        if os.path.exists(tmp_path):
            try:
                os.remove(tmp_path)
            except OSError:
                pass

def read_file(path: str) -> str:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip()
    except FileNotFoundError:
        return ""

def run_cmd(cmd: list[str]) -> tuple[int, str, str]:
    p = subprocess.run(cmd, capture_output=True, text=True)
    return p.returncode, p.stdout.strip(), p.stderr.strip()

def maybe_reload_accel_ppp() -> None:
    """
    Best effort graceful reload, no restart.
    If accel-cmd exists: accel-cmd reload
    Otherwise: do nothing.
    """
    code, out, err = run_cmd(["which", "accel-cmd"])
    if code != 0:
        print("INFO: accel-cmd not found; skipping reload.")
        return

    code, out, err = run_cmd(["accel-cmd", "reload"])
    if code == 0:
        print("INFO: accel-cmd reload OK.")
    else:
        print(f"WARNING: accel-cmd reload failed (code={code}) stderr={err}")

# ----------------------------------------------------
# MAIN
# ----------------------------------------------------
def sync_chap_secrets():
    print(f"\n--- sync_chapsecrets start {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---")

    # 1) Connect DB
    try:
        cnx = pymysql.connect(**DB_CONFIG)
    except pymysql.err.OperationalError as e:
        print(f"ERROR: DB connect failed: {e}")
        return

    rows: list[dict] = []
    try:
        with cnx.cursor() as cursor:
            cursor.execute("""
                SELECT nas_identifier, tunnel_ip
                FROM nas_tunnel_map
                ORDER BY nas_identifier ASC
            """)
            rows = cursor.fetchall()
    finally:
        cnx.close()

    if not rows:
        print("INFO: no rows in nas_tunnel_map; nothing to write.")
        return

    # 2) Build chap-secrets content
    # Format:
    # user server password ip
    # NASID * NASID tunnel_ip
    lines = []
    lines.append("# Auto-generated by sync_chapsecrets.py")
    lines.append("# user            server  password            ip")
    for r in rows:
        nas = str(r["nas_identifier"]).strip()
        ip = str(r["tunnel_ip"]).strip()
        if not nas or not ip:
            continue
        # user == password == nas_identifier (your current approach)
        lines.append(f"{nas} * {nas} {ip}")

    content = ("\n".join(lines) + "\n").encode("utf-8")
    new_hash = sha256_bytes(content)

    # 3) Compare against last hash
    old_hash = read_file(HASH_STATE_PATH)
    if old_hash == new_hash:
        print("OK: chap-secrets unchanged; no action.")
        return

    # 4) Write chap-secrets atomically + save hash
    try:
        # Ensure state directory exists
        os.makedirs(os.path.dirname(HASH_STATE_PATH), exist_ok=True)

        atomic_write(CHAP_SECRETS_PATH, content, mode=0o600)
        atomic_write(HASH_STATE_PATH, (new_hash + "\n").encode("utf-8"), mode=0o600)

        print(f"UPDATED: wrote {CHAP_SECRETS_PATH} ({len(rows)} entries).")
        print(f"UPDATED: new hash saved to {HASH_STATE_PATH}.")

        # 5) Optional reload (safe-ish)
        if TRY_RELOAD_IF_AVAILABLE:
            maybe_reload_accel_ppp()
        else:
            print("INFO: reload disabled (TRY_RELOAD_IF_AVAILABLE=False). New tunnels will work on next connect.")

    except Exception as e:
        print(f"ERROR: failed writing chap-secrets: {e}")

if __name__ == "__main__":
    sync_chap_secrets()
